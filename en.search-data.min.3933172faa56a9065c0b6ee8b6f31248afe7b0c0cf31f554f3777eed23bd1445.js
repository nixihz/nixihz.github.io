'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/tags/fp/','title':"fp",'content':""});index.add({'id':1,'href':'/tags/go/','title':"go",'content':""});index.add({'id':2,'href':'/posts/','title':"posts",'content':"md3s\n"});index.add({'id':3,'href':'/tags/','title':"Tags",'content':""});index.add({'id':4,'href':'/','title':"关于我",'content':"nixihz 尼西赫兹 nixihz is reverse for zhixin\n   Do not go gentle into that good night    "});index.add({'id':5,'href':'/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/','title':"函数式编程入门",'content':"函数式编程特性：  immutable data 不可变数据 first class functions 尾递归优化  函数式编程技术：  map \u0026amp; reduce pipeline recursing 递归 currying 柯里化 higher order function 高阶函数  函数式编程的好处：  parallelization 并行 lazy evaluation 惰性求值 determinism 确定性  "});index.add({'id':6,'href':'/tags/openssl/','title':"openssl",'content':""});index.add({'id':7,'href':'/tools/OpenSSL-%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5/','title':"OpenSSL 工具生成密钥",'content':"第一步 生成RSA密钥\n$openssl\nOpenSSL\u0026gt; genrsa -out app_private_key.pem 2048 OpenSSL\u0026gt; pkcs8 -topk8 -inform PEM -in app_private_key.pem -outform PEM -nocrypt -out app_private_key_pkcs8.pem OpenSSL\u0026gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem OpenSSL\u0026gt; exit  经过以上步骤，开发者可以在当前文件夹中（OpenSSL运行文件夹），看到\n app_private_key.pem（开发者RSA私钥，非 Java 语言适用）、 app_private_key_pkcs8.pem（pkcs8格式开发者RSA私钥，Java语言适用）、 app_public_key.pem（开发者RSA公钥）3个文件。  开发者将私钥保留，将公钥提交给支付宝配置到开发平台，用于验证签名。以下为私钥文件和公钥文件示例。\n 注：对于使用Java的开发者，需将生成的pkcs8格式的私钥去除头尾、换行和空格，作为私钥填入代码中，对于.NET和PHP的开发者来说，无需进行pkcs8命令行操作。\n "});index.add({'id':8,'href':'/tools/','title':"tools",'content':"md\n"});index.add({'id':9,'href':'/tags/development/','title':"development",'content':""});index.add({'id':10,'href':'/tags/git/','title':"git",'content':""});index.add({'id':11,'href':'/tags/git-flow/','title':"git-flow",'content':""});index.add({'id':12,'href':'/tags/standard/','title':"standard",'content':""});index.add({'id':13,'href':'/posts/development-standard/','title':"你必须知道的软件开发规范",'content':"软件版本控制规范 目前 git 较为主流，仅介绍git相关流程规范。git flow 和 github flow\ngit-flow git-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作。\n一图胜千言\nGitHub flow GitHub 流是一个轻量级、基于分支的工作流，支持定期进行部署的团队和项目。https://guides.github.com/introduction/flow/ 解释了 GitHub 流程的工作原理和原因。\n流程就是\n 创建分支 提交代码 创建合代码请求 PullRequest 讨论和代码审查 合并代码  参考资料\n git-flow:  http://danielkummer.github.io/git-flow-cheatsheet/index.html https://nvie.com/posts/a-successful-git-branching-model/ https://github.com/nvie/gitflow https://github.com/petervanderdoes/gitflow-avh 对 nvie 的git-flow做了补充，是目前的主流版本   GitHub flow:  https://guides.github.com/introduction/flow/    软件版本号规范 软件的更新迭代是常态，软件依赖更是需要严格控制版本号，为什么要约定以及如何约定版本号规范，这里有答案《语义化版本 2.0.0》 https://semver.org/，如果你使用 git 做版本控制，那么版本号通常是 tag 名，同时，release通常从 tag 中选取，并丰富修改内容。\n语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立。\n简略归纳几点：\n 版本号 必须 同时记录到文件中。例如 php 的 composer.json version字段，node 的 package.json 字段。 版本号 必须采用 X.Y.Z 格式，X、Y 和 Z 为非负的整数，且 禁止 在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素 必须 以数值来递增。例如：1.9.1 -\u0026gt; 1.10.0 -\u0026gt; 1.11.0。 版本号发行软件包之后，任何调整都 必须 使用新版本号。 开发阶段，主版本号为零，(0.y.z) ，表示非稳定版。 1.0.0 表明该版本可公开使用，并且 api 是稳定的。 先行版本可以追加，范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。 版本编译信息可以追加，范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。 版本优先层级参考，范例：1.0.0-alpha \u0026lt; 1.0.0-alpha.1 \u0026lt; 1.0.0-alpha.beta \u0026lt; 1.0.0-beta \u0026lt; 1.0.0-beta.2 \u0026lt; 1.0.0-beta.11 \u0026lt; 1.0.0-rc.1 \u0026lt; 1.0.0。  "});index.add({'id':14,'href':'/tags/comment/','title':"comment",'content':""});index.add({'id':15,'href':'/tags/php/','title':"php",'content':""});index.add({'id':16,'href':'/posts/PHP%E6%B3%A8%E9%87%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/','title':"PHP注释最佳实践",'content':"const 常量 常量方便了全局值替换，也有了可读性的名字，但是背后的说明不一定能完整体现到常量名中，所以最好写上注释，如下：\nconst CONTRACT_TYPE_ELECTRONIC = 0;//合同类型-电子 const CONTRACT_TYPE_PAPER = 1;//合同类型-纸质  如上注释有个不好的地方，在编辑器 PHPStorm 中，鼠标悬停看不出注释，注释可以做如下调整，即可悬停查看\n/** @var int 合同类型-电子 */ const CONTRACT_TYPE_ELECTRONIC = 0; /** @var int 合同类型-纸质 */ const CONTRACT_TYPE_PAPER = 1  "});index.add({'id':17,'href':'/tags/cache/','title':"cache",'content':""});index.add({'id':18,'href':'/tags/frontend/','title':"frontend",'content':""});index.add({'id':19,'href':'/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98/','title':"浏览器静态资源缓存",'content':"no-cache\n前后端分离坑，\nnginx 配置\nindex index.php index.html index.htm; location / { add_header Cache-Control no-cache; index index.html index.htm; try_files $uri $uri/ /index.html; } "});index.add({'id':20,'href':'/posts/PHP%E8%87%AA%E5%8A%A8%E8%A7%A3%E6%9E%90json%E7%94%9F%E6%88%90php%E7%B1%BB%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84json%E5%88%B0php%E5%AF%B9%E8%B1%A1/','title':"PHP自动解析json生成php类文件，自动映射json到php对象",'content':"业务中经常需要对接第三方服务，常用的对接方式就是使用 http json 接口，有些 json 格式较为复杂，使用php数组进行数据交互非常麻烦，非常容易出错。\n $responseStr = '{\u0026quot;foo\u0026quot;:\u0026quot;bar\u0026quot;, \u0026quot;hello\u0026quot;:\u0026quot;world\u0026quot;}'; $responseArr = json_decode($responseStr, true); if($responseArr[\u0026quot;fooo\u0026quot;] == \u0026quot;foobar\u0026quot;) { // do sth. }  现在 IDE 比如 PHPStorm 也不能对数组 进行代码提示，上面的代码是不会有错误提示的；如果把 json 返回值直接映射到预先定义好的对象，岂不是很舒心？\n一、映射 json 到 php 对象 我们可以使用 composer 包: nixihz/php-object ，支持复杂 json 到 复杂对象之间的映射。\n composer require nixihz/php-object class FooBarClass extends PhpObject { /** @var string */ public $foo; /** @var integer */ public $bar; } class DemoClass extends PhpObject { /** @var FooBarClass */ public $foobar; /** @var FooBarClass[] */ public $foobars; } $json = '{\u0026quot;foobar\u0026quot;:{\u0026quot;foo\u0026quot;:\u0026quot;hello world\u0026quot;,\u0026quot;bar\u0026quot;:64100},\u0026quot;foobars\u0026quot;:[{\u0026quot;foo\u0026quot;:\u0026quot;hello\u0026quot;,\u0026quot;bar\u0026quot;:641},{\u0026quot;foo\u0026quot;:\u0026quot;world\u0026quot;,\u0026quot;bar\u0026quot;:664411}]}'; $demo = (new DemoClass())-\u0026gt;fromJson($json); if($demo-\u0026gt;foobar-\u0026gt;foo == \u0026quot;hello world\u0026quot;) { echo count($demo-\u0026gt;foobars); } var_export($demo);  输出\n 2 DemoClass::__set_state(array( 'foobar' =\u0026gt; FooBarClass::__set_state(array( 'foo' =\u0026gt; 'hello world', 'bar' =\u0026gt; 64100, )), 'foobars' =\u0026gt; array ( 0 =\u0026gt; FooBarClass::__set_state(array( 'foo' =\u0026gt; 'hello', 'bar' =\u0026gt; 641, )), 1 =\u0026gt; FooBarClass::__set_state(array( 'foo' =\u0026gt; 'world', 'bar' =\u0026gt; 664411, )), ), ))  下一步，这个工具将会提供直接从 json 生成 php 类代码的辅助功能，将会更大提升对接效率。\n。。。\n二、解析 json 自动生成 php 类文件 来填坑了，安装好 composer require nixihz/php-object 以后，可以使用脚本 vendor/bin/php-object-gen 来直接生成代码到指定文件夹。\nUsage：\n  示例\n$./vendor/bin/php-object-gen \u0026ndash;path=/tmp \u0026ndash;json='{\u0026ldquo;foo_bar\u0026rdquo;:{\u0026ldquo;foo\u0026rdquo;:1.3,\u0026ldquo;bar\u0026rdquo;:[641,641]}}'\noutput Class FooBar saved at: /tmp/FooBar.php Class BaseClass saved at: /tmp/BaseClass.php\n  -help 查看帮助\n$./vendor/bin/php-object-gen \u0026ndash;help output php object generator\nUsage: ./vendor/bin/php-object-gen \u0026ndash;path=/tmp \u0026ndash;json='{\u0026ldquo;foo_bar\u0026rdquo;:{\u0026ldquo;foo\u0026rdquo;:1.3,\u0026ldquo;bar\u0026rdquo;:[641,641]}}'\nFlags: \u0026ndash;path path to save class files (存储类文件路径) \u0026ndash;baseClassName base class name (最外层类名) \u0026ndash;fieldCase field case type 0:keep, 1:snake case, 2:camel case (字段形式) \u0026ndash;namespace namespace for class (类命名空间) \u0026ndash;json json input (待解析的json文件) \u0026ndash;help print this help (输出当前帮助信息)\n   https://github.com/nixihz/php-object\n "});index.add({'id':21,'href':'/sharpen-knife/PHP-storm-%E6%B3%A8%E9%87%8A%E7%AC%A6%E5%8F%B7%E5%9C%A8%E8%A1%8C%E9%A6%96%E8%A7%A3%E5%86%B3/','title':"PHP storm 注释符号在行首",'content':"问题 PHP storm 默认设置 注释快捷键 设置的行注释 设置在行首，如下：❌\n // todo 使用队列, 替换 raise dispatchNow $thread-\u0026gt;raise(new Created($thread)); // ProcessThreadCreated::dispatchNow($thread); ProcessThreadCreated::dispatch($thread);  使用 格式化 功能以后，格式又发生错乱，❌\n // todo 使用队列, 替换 raise dispatchNow $thread-\u0026gt;raise(new Created($thread)); // ProcessThreadCreated::dispatchNow($thread); ProcessThreadCreated::dispatch($thread);  注释时直接 注释在代码前，而非行首，如下：✅\n // todo 使用队列, 替换 raise dispatchNow $thread-\u0026gt;raise(new Created($thread)); //ProcessThreadCreated::dispatchNow($thread); ProcessThreadCreated::dispatch($thread)  解决  设置， 取消勾选 Line Comment at first column  Settings - Editor - Code Style - PHP - Code Generation\n 自动格式化配置，取消勾选 Comment at first column  Settings - Editor - Code Style - PHP - Wrapping and Braces\n"});index.add({'id':22,'href':'/sharpen-knife/','title':"sharpen-knife",'content':"md\n"});index.add({'id':23,'href':'/sharpen-knife/Oh-My-ZSH-on-iTerm-2-%E8%AE%A9Mac%E6%9B%B4%E8%B6%81%E6%89%8B/','title':"Oh My ZSH on iTerm 2 让Mac更趁手",'content':"Oh My ZSH 配置 https://ohmyz.sh/\n插件 autojump\nzsh-autosuggestions\nzsh-syntax-highlighting\n一些 iTerm2 tips iTerm2 使用 sz rz windows xshell 连接远程服务器后与windows电脑互传文件很方便，到了 mac terminal 就不行了，这里推荐一个github项目，原本是某个国外大佬的，结果这个家伙支持藏独，在文件里藏着某些敏感信息，后来前同事把代码拉下来去掉敏感信息后放到自己的项目中。\nhttps://github.com/aikuyun/iterm2-zmodem\n服务端安装 lrzsz: yum install lrzsz\n注意：可以利用 mac自带控制台应用 来排查\n命令行中使用代理 通过设置环境变量 http_proxy\nexport http_proxy=http://127.0.0.1:7777;export https_proxy=http://127.0.0.1:7777;  配置 badge 徽章 区分环境\n快捷键 cmd + t\t新建tab cmd + d\t垂直分屏 cmd + shift + d\t水平分屏 cmd + 1~9\t切换tab cmd + o\t打开profile "});index.add({'id':24,'href':'/sharpen-knife/PHPStorm-Visual-Studio-Code-Vim-%E7%86%9F%E6%82%89%E8%BF%99%E4%BA%9B%E7%89%B9%E6%80%A7%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87/','title':"PHPStorm | Visual Studio Code |Vim 熟悉这些特性，提升效率",'content':"PhpStorm 语法错误等提示和检测，调用跳转，代码生成，调试功能，代码全局观，文件管理，版本控制工具，数据库查看，命令行工具，丰富的扩展库。\n文件检测 目录树选中文件，右击，点击 Inspect code … 执行代码检查\n跳转 cmd + 鼠标左键\ncmd + [ 依次返回历史跳转点\ncmd + ] 重新回到最新跳转点\n文件管理 Favorites 文件，根据某个功能特定文件，\nBookmarks\n代码生成 cmd + n 生成代码，弹框中选择生成 Copyright, Getter Setter，注释等\n代码补全 输入 fore 按下回车生成 foreach 代码块 （Goland 也有类似的快捷短语）\n插件 PHP Advanced AutoComplete Thomas Schulz ，可以自动补全，舒心\n定位到当前正在编辑的文件 数据库插件 使用体验与 jetbrains 旗下 Datagrip 非常一致；\n可以在项目中增加 sql 文件夹，存放相关sql；\ncmd + enter 执行光标所在行的sql语句，可以在弹框选择子查询；\ncmd + option + l(小写L) 格式化代码，\ncmd + ，设置中搜索 sql 选择 code style， 可个性化配置sql代码风格。\n比如关键词全部大写，SELECT 子句逗号前置，SELECT 元素独占一行。\nvim插件 享受各个 IDE 一致性的体验。\n一些快捷键 RendeRenderCollectionViewrCode NYI\nVisual Studio Code vim插件 享受各个 IDE 一致性的体验。\nVim 插件\nhttps://github.com/scrooloose/nerdtree.git\nhttps://github.com/vim-airline/vim-airline\nhttps://github.com/vim-airline/vim-airline-themes\n配置\n做好配置，可以放到 git 托管。\nhttps://github.com/fencex/myvim.git\nvim 基础 RendeRenderCollectionViewrCode NYI\n编辑操作 RendeRenderCollectionViewrCode NYI\nVisual 模式 RendeRenderCollectionViewrCode NYI\n一般跟其他命令结合使用，比如 shift + v 选择多行， 再按 d， 删除所选行\n命令 RendeRenderCollectionViewrCode NYI\n其他  shift + j 当前行移动到上一行行尾, 可以做到单列转单行 shift + u 转换成大写 ~ 大小写互换  "});index.add({'id':25,'href':'/sharpen-knife/MacOS%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/','title':"MacOS必备软件",'content':"Magnet 一款辅助视窗排版的软件，花6块钱实现与windows自带的排版相同的体验吧。\n"});index.add({'id':26,'href':'/sharpen-knife/MacOS%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%92%8C%E8%AE%BE%E7%BD%AE%E8%AE%A9Mac%E6%9B%B4%E8%B6%81%E6%89%8B/','title':"MacOS系统配置和设置，让Mac更趁手",'content':"触摸板 🔵 滚动方向：自然，设计思路：内容虽手指移动， 推荐勾选 ✅\n🔘滚动方向：自然，设计思路：我要看下面的内容，手指就往下滑\n🔵 轻点来点按， 勾选上，可以触摸来点击，否则需要用力按下，非常废手指，因此强烈推荐勾选上✅。\n三指拖动 还有一个操作非常费手指，选中部分文本, mac 提供一个解决方案：三指拖动，其实就是使用三指滑动来实现单击并拖拽。\n 移动窗口 选中文本  三指滑动开始选中，可以多次滑动来调整结束位置，(注意中间的停顿不能太久)。\n触发角功能 我个人比较喜欢这个功能，屏幕有四个活跃触发角，可以设定不同的功能，比如调度中心，应用程序窗口，说的花里胡哨的，窗口缩略图，当前焦点应用的窗口缩略图。\n我比较喜欢的设置如图。\n左下角设置成启动屏幕保护程序 ，老板走过来了，立马用鼠标或者触摸板把光标移动到左下角。程序员的电脑重要数据还是比较多的，为安全考虑，建议大家设置，或者你也可以直接盖上盖子。\n当然这一步仅是启动了屏保，大家设置了以后可能敲击键盘，或者移动鼠标，就退出屏保动画，进入系统了。\n进一步操作，让电脑进入屏保立马锁定电脑。如下图：\n大家可以体验一下，设定启动屏保的触发角，鼠标指针停留一段时间才会触发，而其他则立即触发，这些都是细节，真牛*。\n其他  触摸板双指滑动，切换上一页下一页 双指点击，放大缩小 双指右侧滑动，打开通知窗口， 大家分享时，记得开启勿扰模式  键盘  按键重复 和 重复前延迟设置最快和最短移动光标体验起飞。 开发常用F1-F12功能键，推荐使用按 Fn 键以 显示 F1、F2 等键  一些快捷键 /table\nRendeRenderCollectionViewrCode NYI\n一些光标定位快捷键 RendeRenderCollectionViewrCode NYI\n"});index.add({'id':27,'href':'/tags/app/','title':"app",'content':""});index.add({'id':28,'href':'/tags/flutter/','title':"flutter",'content':""});index.add({'id':29,'href':'/flutter-music-app/Flutter-%E9%9F%B3%E4%B9%90-app-%E4%B9%8B-%E5%8A%A0%E4%B8%80%E4%B8%AA-WiFi-%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%8A%9F%E8%83%BD%E5%90%A7/','title':"Flutter 音乐 app 之 加一个 WiFi 文件同步功能吧",'content':"既然是音乐播放器，那得搞些资源放进手机吧，兄弟你看小说吗？很多 app 有通过 Wi-Fi 把书传入手机的功能，效果还行，那就这么搞吧。\n简单画一个图：\n先看下实际效果图吧！\nFlutter 启动 http 服务 使用 内置的 HttpServer ，代码如下：\nimport 'dart:io'; server = await HttpServer.bind( hostIp, 8080, );  这就启动了一个 http 服务，这不是搞笑呢吗？请求咋处理，静态资源咋放这咋没说呢，稍候我先去吃个饭。\n服务路由 由于该服务只有特定的几个功能，创建文件夹，获取列表，上传文件，删除文件，以及前端页面文件，所以路由功能直接根据 request uri ，进行 switch case 即可，代码如下：\n// runZoned 捕获异步异常 var runZoned2 = runZoned(() async { await for (var request in server) { switch (request.uri.toString().split(\u0026quot;?\u0026quot;).first) { case '/upload': _uploadController(request); break; case '/musicList': _musicListController(request); break; case '/deleteMusicInfo': _deleteMusicController(request); break; case '/createFold': _createFoldController(request); break; case '/': _homeController(request); break; default: _publicController(request); break; } } }, onError: (Object obj, StackTrace stack) { print(obj); print(stack); }); }  请求前端文件 前端功能不复杂，但是有一些交互，直接用 Vue 写一个 SPA，来的快一些。vue 打包以后把所有的文件放在 {project}/assets/httpserver/ 文件夹下即可访问。\n比较难受的是，http 响应头 Response Header 中 ContentType Content-Length 等要自己写，不能自动识别，这个比较考验 http 基本概念的理解了，如果有更好的实现方式，请留言，先谢过了。\n// http 的静态资源资源 _publicController(HttpRequest request) { String filePath = \u0026quot;assets/httpserver/public\u0026quot; + request.uri.path.toString(); String filetype = filePath.split('.').last; String type1 = 'text'; String type2 = 'html'; if (filetype == 'html') { type2 = 'html'; } else if (filetype == 'js') { type1 = 'application'; type2 = 'javascript'; } else if (filetype == 'css') { type2 = 'css'; } else if (filetype == 'ico') { type2 = 'ico'; } else if (filetype == 'png') { type1 = 'image'; type2 = 'png'; } else if (filetype == 'map') { type2 = 'html'; } else if (filetype == 'woff') { type1 = 'font'; type2 = 'woff'; } if (type2 == \u0026quot;woff\u0026quot; || type2 == \u0026quot;ttf\u0026quot; || type2 == \u0026quot;ico\u0026quot; || type2 == \u0026quot;png\u0026quot;) { rootBundle.load(fielPath).then((value) { request.response ..headers.clear() ..headers.contentType = new ContentType(type1, type2, charset: \u0026quot;UTF-8\u0026quot;) ..headers.set(\u0026quot;Accept-Ranges\u0026quot;, \u0026quot;bytes\u0026quot;) ..headers.set(\u0026quot;Connection\u0026quot;, \u0026quot;keep-alive\u0026quot;) ..headers.set(\u0026quot;Content-Length\u0026quot;, value.lengthInBytes) ..add(value.buffer.asUint8List()) ..close(); }); } else { rootBundle.load(fielPath).then((value) { request.response ..headers.clear() ..headers.contentType = new ContentType(type1, type2, charset: \u0026quot;UTF-8\u0026quot;) ..headers.set(\u0026quot;Accept-Ranges\u0026quot;, \u0026quot;bytes\u0026quot;) ..headers.set(\u0026quot;Connection\u0026quot;, \u0026quot;keep-alive\u0026quot;) ..headers.set(\u0026quot;Content-Length\u0026quot;, value.lengthInBytes) ..write(utf8.decode(value.buffer.asUint8List())) ..close(); }); } }  请求功能接口 相较于静态文件，接口反而简单点，以 音乐列表 示例：\n功能：传入一个 文件路径，获取该路径下的音乐文件列表。\n  获取 GET 参数 path： request.uri.queryParameters[\u0026quot;path\u0026quot;]\n  从 sqlite 读取数据\n  按照与前端约定的格式响应 json\n// 列表页 _musicListController(HttpRequest request) async { HttpBodyHandler.processRequest(request).then((body) async { String musicPath = request.uri.queryParameters[\u0026ldquo;path\u0026rdquo;];\n // 从 sqlite 读取数据 DBProvider.db.getMusicInfoByPath(musicPath).then((onValue) { Map map = new Map(); map[\u0026quot;List\u0026quot;] = onValue; map[\u0026quot;Total\u0026quot;] = onValue.length; // HttpServerUtils 代码文件见附录： HttpServerUtils.response(request, 200, \u0026quot;Success\u0026quot;, map); }); }); }    附录： HttpServerUtils.dart\nimport 'dart:convert'; import 'dart:io'; class HttpServerUtils { static response(HttpRequest httpRequest, int code, String msg, Map data) { var resp = \u0026quot;{}\u0026quot;; Responses response = new Responses(data: data, code: 200, message: \u0026quot;Success\u0026quot;); resp = jsonEncode(response); httpRequest.response ..headers.clear() ..headers.contentType = new ContentType(\u0026quot;application\u0026quot;, \u0026quot;json\u0026quot;, charset: \u0026quot;UTF-8\u0026quot;) ..headers.set(\u0026quot;Accept-Ranges\u0026quot;, \u0026quot;bytes\u0026quot;) ..headers.set(\u0026quot;Connection\u0026quot;, \u0026quot;keep-alive\u0026quot;) ..headers.set(\u0026quot;Content-Length\u0026quot;, utf8.encode(musicInfoJson).length) ..add(utf8.encode(resp)) ..close(); } } // 自定义响应的格式 class Responses { final Map data; final int code; final String message; Responses({this.data, this.code, this.message}); Map toJson() { Map map = new Map(); map[\u0026quot;Data\u0026quot;] = this.data; map[\u0026quot;Code\u0026quot;] = this.code; map[\u0026quot;Message\u0026quot;] = this.message; return map; } } "});index.add({'id':30,'href':'/flutter-music-app/','title':"flutter-music-app",'content':"md\n"});index.add({'id':31,'href':'/tags/wifi-sync/','title':"wifi sync",'content':""});index.add({'id':32,'href':'/flutter-music-app/%E5%BC%80%E7%AF%87%E8%AF%8D/','title':"开篇词",'content':"过年没啥事，写一个 flutter 音乐播放器吧\n"});index.add({'id':33,'href':'/posts/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE-npm-%E5%8C%85%E7%AE%A1%E7%90%86%E8%8E%AB%E5%90%8D%E5%8D%87%E7%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/','title':"前端项目 npm 包管理莫名升级问题排查",'content':"package.json 和 package-lock.json 是控制node_module包版本的两个文件，其中 package.json 由开发者维护，package-lock.json 自动生成。\n一般package.json 指定版本都会使用 ^ 或者 ~ ，举例：\n\u0026quot;dependencies\u0026quot;: { \u0026quot;vue\u0026quot;: \u0026quot;^2.6.11\u0026quot;, \u0026quot;vue-pdf\u0026quot;: \u0026quot;~4.0.8\u0026quot; }  ^2.6.11 表示该模块的小版本向下兼容，\n~4.0.8 表示该模块的中间\n执行 npm install 到底发生了什么；\n~1.2.3 代表 1.2.3 \u0026lt;= 版本号 \u0026lt; 1.3.0\n^1.2.3 代表 1.2.3 \u0026lt;= 版本号 \u0026lt; 2.0.0\n1，^ 符号，它与semantic versioning （语义版本控制）有关系，它表示尽量使用最新版本，但保证不产生兼容问题，换句话说也就是除了大版本号以外，小版本号和补丁版本号都可以变。 但0 开头的版本号是比较特殊的，而因为 ^ 严格遵守 semantic versioning 规则，所以会出现以下情况（早先的 composer 版本并没有这样的处理，后来修正了）：^0.3.0 等于 \u0026gt;=0.3.0; \u0026lt;0.4.0，并不是\u0026lt;1.0.0 ，因为，semantic versioning 的规定是，大版本号以 0 开头表示这是一个非稳定版本（unstable），如果处于非稳定状态，小版本号是允许不向下兼容的！\n2，~符号，表示版本号只能改变最末尾那段（如果是 ~x.y 末尾就是 y，如果是 ~x.y.z 末尾就是 z），比如这种情况:\n~1.2 等于 \u0026gt;=1.2.0; \u0026lt;2.0.0\n3，因为0的特殊性所以如果你要指定 0 开头的库那一定要注意：\n~0.1 这种写法是很危险的，因为 ~0.1 等于 \u0026gt;=0.1.0; \u0026lt;1.0.0，可能出现无法向下兼容的情况，比较保险的写法还是：^0.1（等于 \u0026gt;=0.1.0; \u0026lt;0.2.0）\n"});index.add({'id':34,'href':'/posts/SPA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5/','title':"SPA前端项目灰度发布策略",'content':"前提 B/S 项目的灰度发布本应完全由服务端控制，但是SPA的出现打破了这个局面，B/S变得越来越像C/S，故发布策略也需要做相应调整。\n灰度发布（又名金丝雀发布），在此基础上，我们可以做内测，也可以做 A/B 测试，战略意义还是很大的。\n简单思路todo： 常规项目 npm 打包，同一版本的代码，每次打包静态文件名必须一致，\nwebpack中hash、chunkhash、contenthash 区别\n使用 contenthash 作文件名， 或者使用自定义版本号来维护。\n打包完成，手动提交版本号到服务端，由服务端纳入灰度发布的控制\n项目入口文件 不再直接使用 dist/index.html\n而是由服务端来控制\n用户登录后，服务端可以任意控制用户应该访问哪个版本的前端；\n前端项目的每次请求都必须带上版本号：由服务端处理做后续处理，\n比如：\n有版本太旧，可提示用户刷新，刷新以后依然如此，可以提示向后台反馈；\n好处：\n 提前获得目标用户的使用反馈； 根据反馈结果，做到查漏补缺； 发现重大问题，可回滚“旧版本”； 补充完善产品不足； 快速验证产品的 idea。  "});index.add({'id':35,'href':'/posts/PHP%E5%AF%B9%E6%8E%A5-wsdl-soap-%E6%8E%A5%E5%8F%A3/','title':"PHP 对接 wsdl soap 接口",'content':"概念\nSOAP\nWSDL\nWSDL 描述了业务方法，各语言基本都提供了工具可以自动生成代码，可以直接调用；对接就变得非常简单，拢共就2步骤：\n 自动生成接口代码 封装 service 提供给业务调用  1. 自动生成接口代码 PHP 要处理 SOAP，可以使用这个库，https://github.com/phpro/soap-client\n$ composer require phpro/soap-client $ ./vendor/bin/soap-client wizard Where would you like to store your config file? [config/soap-client.php]: \u0026gt; common/config/soap-client.php Wsdl location (URL or path to file): \u0026gt; common/config/standard-prod.wsdl Generic name used to name this client (Results in \u0026lt;name\u0026gt;Client \u0026lt;name\u0026gt;Classmap etc.): \u0026gt; GoogleMap Directory where the client should be generated in: \u0026gt; common/libs/googlemap Namespace for your client: \u0026gt; common\\libs\\googlemap [OK] Config has been written to common/config/soap-client.php Generated class common\\libs\\googlemap\\Type\\PingRequest to common/libs/googlemap/Type/PingRequest.php ... [OK] All SOAP types generated [OK] Generated classmap at common/libs/googlemap/GoogleMapClassmap.php [OK] Generated client at common/libs/googlemap/GoogleMapClient.php [OK] Generated client factory at common/libs/googlemap/GoogleMapClientFactory.php  2. 封装 service 提供给业务调用 \u0026lt;?php namespace service\\supplier\\googlemap; use common\\libs\\googlemap\\GooglaMapClientFactory; class MapService { protected $client; public function __construct() { $this-\u0026gt;client = GooglaMapClientFactory::factory(\u0026quot;/path/to/config/standard-prod.wsdl\u0026quot;); } // 调用 soap 实际业务方法 public function getA() { return $this-\u0026gt;client-\u0026gt;getA(); } }  写在结尾 越来越多接口提供商都不再使用 wsdl / soap 对外服务了，性能很差，我对接过的服务商基本都改成轻量的 json 格式，甚至改成了 grpc\n"});index.add({'id':36,'href':'/blog/new-url/','title':"template",'content':""});index.add({'id':37,'href':'/categories/','title':"Categories",'content':""});})();