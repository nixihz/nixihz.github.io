'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/tags/development/','title':"development",'content':""});index.add({'id':1,'href':'/tags/git/','title':"git",'content':""});index.add({'id':2,'href':'/posts/git-flow/','title':"Git 开发流程 git-flow",'content':"安装 初始化项目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  git flow init # 然后一路回车 Which branch should be used for bringing forth production releases? - main Branch name for production releases: [main] Branch name for \u0026#34;next release\u0026#34; development: [develop] How to name your supporting branch prefixes? Feature branches? [feature/] Bugfix branches? [bugfix/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] Hooks and filters directory? [/data/demo/.git/hooks]   Feature 分支新功能开发 开发环节：  开启一个新分支 立即推送到远端，避免同事推送了相同的分支  1 2 3 4 5  # 开启一个分支 git flow feature start pre-release-config # 推送提交到远端，效果等同于 git push origin feature/pre-release-config git flow publish   上线环节：  feature分支开发完成，代码会合并到本地 develop 开启一个 release 分支，一般分支名为版本号，如：v1.0.0.0 完成release分支，会新建一个 release 分支命名的 tag 如： v1.0.0.0 推送 develop 和 main 分支到远端 将 tag 推送到远端  以上 5 步基本都是直接完成，不会穿插其他环节，完成后线上可以基于 main 分支发布或者基于对应版本的 tag 进行部署发布了。\n需要注意的是：在开启 release 分支之前，可以对多个 feature 分支进行合并。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # feature 分支开发完成，代码会合并到 develop git flow feature finish # 开启 release 分支 git flow release start v1.0.0.0 # release 分支完成，新建 release 分支命名的 tag 如：v1.0.0.0，并需填写 tag 的备注信息 git flow release finish # 以上操作除了 git flow publish 都是本地分支进行操作， # 最后需要推送 develop 和 main 分支以及 tag 到远端 git checkout develop git flow publish git checkout main git flow publish git push --tag   Hotfix 分支功能修复 hotfix 与 feature 大同小异，主要差异体现在 release 分支，具体见下文\n开发环节：  开启新分支 立即推送到到远端，避免同事推送相同的分支  1 2 3 4 5  # 开启一个分支 git flow feature start typo-fix # 推送提交到远端，效果等同于 git push origin hotfix/typo-fix git flow publish   上线环节：  hotfix 分支开发完成，会直接创建 tag，并且以hotfix分支命名，但是建议带上参数 -T 重新命名 推送 develop 和 main 分支到远端 将 tag 推送到远端  可以看到与 feature 开发不同的是，hotfix 不需要通过创建 release，可以快速操作，毕竟我们是修复，需要尽快操作完成上线。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # hotfix 分支开发完成，并且以为 v1.0.0.1 命名建立一个新tag git flow hotfix finish -T v1.0.0.1 # 如果有多个 hotfix ，建议在 finish 后跟上具体的 hotfix 分支名 git flow hotfix finish typo-fix -T v1.0.0.1 # 最后需要推送 develop 和 main 分支以及 tag 到远端 git checkout develop git flow publish git checkout main git flow publish git push --tag   "});index.add({'id':3,'href':'/posts/','title':"posts",'content':"md\n"});index.add({'id':4,'href':'/tags/','title':"Tags",'content':""});index.add({'id':5,'href':'/','title':"关于我",'content':"nixihz 尼西赫兹 nixihz is reverse for zhixin\n   Do not go gentle into that good night    "});index.add({'id':6,'href':'/tags/doc/','title':"doc",'content':""});index.add({'id':7,'href':'/doc/','title':"doc",'content':"md\n"});index.add({'id':8,'href':'/doc/%E4%B8%8A%E7%BA%BF%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/','title':"开发文档模板",'content':"todo\n"});index.add({'id':9,'href':'/doc/%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/','title':"开发文档模板",'content':""});index.add({'id':10,'href':'/tags/fp/','title':"fp",'content':""});index.add({'id':11,'href':'/tags/go/','title':"go",'content':""});index.add({'id':12,'href':'/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/','title':"函数式编程入门",'content':"函数式编程特性：  immutable data 不可变数据 first class functions 尾递归优化  函数式编程技术：  map \u0026amp; reduce pipeline recursing 递归 currying 柯里化 higher order function 高阶函数  函数式编程的好处：  parallelization 并行 lazy evaluation 惰性求值 determinism 确定性  "});index.add({'id':13,'href':'/tags/openssl/','title':"openssl",'content':""});index.add({'id':14,'href':'/tools/OpenSSL-%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5/','title':"OpenSSL 工具生成密钥",'content':"第一步 生成RSA密钥\n1 2 3 4 5 6 7 8 9  $openssl OpenSSL\u0026gt; genrsa -out app_private_key.pem 2048 OpenSSL\u0026gt; pkcs8 -topk8 -inform PEM -in app_private_key.pem -outform PEM -nocrypt -out app_private_key_pkcs8.pem OpenSSL\u0026gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem OpenSSL\u0026gt; exit   经过以上步骤，开发者可以在当前文件夹中（OpenSSL运行文件夹），看到\n app_private_key.pem（开发者RSA私钥，非 Java 语言适用）、 app_private_key_pkcs8.pem（pkcs8格式开发者RSA私钥，Java语言适用）、 app_public_key.pem（开发者RSA公钥）3个文件。  开发者将私钥保留，将公钥提交给支付宝配置到开发平台，用于验证签名。以下为私钥文件和公钥文件示例。\n 注：对于使用Java的开发者，需将生成的pkcs8格式的私钥去除头尾、换行和空格，作为私钥填入代码中，对于.NET和PHP的开发者来说，无需进行pkcs8命令行操作。\n "});index.add({'id':15,'href':'/tools/','title':"tools",'content':"md\n"});index.add({'id':16,'href':'/tags/api/','title':"api",'content':""});index.add({'id':17,'href':'/tags/backend/','title':"backend",'content':""});index.add({'id':18,'href':'/tags/frontend/','title':"frontend",'content':""});index.add({'id':19,'href':'/posts/%E4%B8%80%E7%A7%8D%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E5%9F%BA%E4%BA%8EGoogle-Json-Style/','title':"一种好用的接口请求和响应格式规范，基于Google Json Style",'content':"简述  基于较为流行的谷歌 json 风格 google json style  英文 https://google.github.io/styleguide/jsoncstyleguide.xml 中文 https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md   所有字段驼峰命名，接口使用：get post  get 获取数据 post 更新数据   post：请求 body 数据使用 application/json, 不使用 FormData; 响应成功，仅返回 data；响应错误，仅返回 error。如果data和error同时出现，则error对象优先。 HTTP_STATUS 始终200， 如果非 200，则说明出现错误，提示“服务器异常”。  POST 请求： 1 2 3 4 5 6 7 8  { \u0026#34;method\u0026#34;: \u0026#34;thread.review.list 可简化\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;id\u0026#34;: 100, \u0026#34;type\u0026#34;: 1 } }   接口响应： 正确响应  列表响应 items  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  { \u0026#34;apiVersion\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;thread.review.list\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;tableHeader\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;ID\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;标题\u0026#34; }, \u0026#34;items\u0026#34;: [ { \u0026#34;id\u0026#34;: 10021, \u0026#34;name\u0026#34;: \u0026#34;第一个帖子\u0026#34; } ], \u0026#34;pagination\u0026#34;: { \u0026#34;pageIndex\u0026#34;: 50, \u0026#34;totalPages\u0026#34;: 10, \u0026#34;itemsPerPage\u0026#34;: 50, \u0026#34;totalItems\u0026#34;: 495, \u0026#34;currentItemCount\u0026#34;: 45 } } }    详细数据响应 item  1 2 3 4 5 6 7 8 9 10 11  { \u0026#34;apiVersion\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;thread.review.detail\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;item\u0026#34;: { \u0026#34;id\u0026#34;: 10031, \u0026#34;name\u0026#34;: \u0026#34;第一个帖子\u0026#34; } } }   发生错误 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  { \u0026#34;apiVersion\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;thread.review.list\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: 400, \u0026#34;message\u0026#34;: \u0026#34;数据异常\u0026#34;, \u0026#34;errors\u0026#34;: [ { \u0026#34;domain\u0026#34;: \u0026#34;Calendar\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;ResourceNotFoundException\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;File Not Found\u0026#34; } ] } }   错误处理  响应存在 error 则说明发生错误，error 优先级高于 data error.message 始终 toast 提示 特殊逻辑处理根据 error.code 进行判断 HTTP_STATUS 始终200， 如果非 200，则说明出现错误，提示“服务器异常” 调用接口成功响应，提示文案由前端处理 业务中的特殊逻辑，在 data 返回处理  特殊 error.code 列表 见仁见智\n   逻辑 error.code error.message 备注     跳转到登录页 10000100 登录失效，请重新登录    刷新页面 10000101 -    跳转到指定404页面 10000102 -     "});index.add({'id':20,'href':'/tags/git-flow/','title':"git-flow",'content':""});index.add({'id':21,'href':'/tags/standard/','title':"standard",'content':""});index.add({'id':22,'href':'/posts/development-standard/','title':"你必须知道的软件开发规范",'content':"软件版本控制规范 目前 git 较为主流，仅介绍git相关流程规范。git flow 和 github flow\ngit-flow git-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作。\n一图胜千言\nGitHub flow GitHub 流是一个轻量级、基于分支的工作流，支持定期进行部署的团队和项目。https://guides.github.com/introduction/flow/ 解释了 GitHub 流程的工作原理和原因。\n流程就是\n 创建分支 提交代码 创建合代码请求 PullRequest 讨论和代码审查 合并代码  参考资料\n git-flow:  http://danielkummer.github.io/git-flow-cheatsheet/index.html https://nvie.com/posts/a-successful-git-branching-model/ https://github.com/nvie/gitflow https://github.com/petervanderdoes/gitflow-avh 对 nvie 的git-flow做了补充，是目前的主流版本   GitHub flow:  https://guides.github.com/introduction/flow/    软件版本号规范 软件的更新迭代是常态，软件依赖更是需要严格控制版本号，为什么要约定以及如何约定版本号规范，这里有答案《语义化版本 2.0.0》 https://semver.org/，如果你使用 git 做版本控制，那么版本号通常是 tag 名，同时，release通常从 tag 中选取，并丰富修改内容。\n语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立。\n简略归纳几点：\n 版本号 必须 同时记录到文件中。例如 php 的 composer.json version字段，node 的 package.json 字段。 版本号 必须采用 X.Y.Z 格式，X、Y 和 Z 为非负的整数，且 禁止 在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素 必须 以数值来递增。例如：1.9.1 -\u0026gt; 1.10.0 -\u0026gt; 1.11.0。 版本号发行软件包之后，任何调整都 必须 使用新版本号。 开发阶段，主版本号为零，(0.y.z) ，表示非稳定版。 1.0.0 表明该版本可公开使用，并且 api 是稳定的。 先行版本可以追加，范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。 版本编译信息可以追加，范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。 版本优先层级参考，范例：1.0.0-alpha \u0026lt; 1.0.0-alpha.1 \u0026lt; 1.0.0-alpha.beta \u0026lt; 1.0.0-beta \u0026lt; 1.0.0-beta.2 \u0026lt; 1.0.0-beta.11 \u0026lt; 1.0.0-rc.1 \u0026lt; 1.0.0。  "});index.add({'id':23,'href':'/posts/development-standard/','title':"你必须知道的软件开发规范",'content':"软件版本控制规范 目前 git 较为主流，仅介绍git相关流程规范。git flow 和 github flow\ngit-flow git-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作。\n一图胜千言\nGitHub flow GitHub 流是一个轻量级、基于分支的工作流，支持定期进行部署的团队和项目。https://guides.github.com/introduction/flow/ 解释了 GitHub 流程的工作原理和原因。\n流程就是\n 创建分支 提交代码 创建合代码请求 PullRequest 讨论和代码审查 合并代码  参考资料\n git-flow:  http://danielkummer.github.io/git-flow-cheatsheet/index.html https://nvie.com/posts/a-successful-git-branching-model/ https://github.com/nvie/gitflow https://github.com/petervanderdoes/gitflow-avh 对 nvie 的git-flow做了补充，是目前的主流版本   GitHub flow:  https://guides.github.com/introduction/flow/    软件版本号规范 软件的更新迭代是常态，软件依赖更是需要严格控制版本号，为什么要约定以及如何约定版本号规范，这里有答案《语义化版本 2.0.0》 https://semver.org/，如果你使用 git 做版本控制，那么版本号通常是 tag 名，同时，release通常从 tag 中选取，并丰富修改内容。\n语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立。\n简略归纳几点：\n 版本号 必须 同时记录到文件中。例如 php 的 composer.json version字段，node 的 package.json 字段。 版本号 必须采用 X.Y.Z 格式，X、Y 和 Z 为非负的整数，且 禁止 在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素 必须 以数值来递增。例如：1.9.1 -\u0026gt; 1.10.0 -\u0026gt; 1.11.0。 版本号发行软件包之后，任何调整都 必须 使用新版本号。 开发阶段，主版本号为零，(0.y.z) ，表示非稳定版。 1.0.0 表明该版本可公开使用，并且 api 是稳定的。 先行版本可以追加，范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。 版本编译信息可以追加，范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。 版本优先层级参考，范例：1.0.0-alpha \u0026lt; 1.0.0-alpha.1 \u0026lt; 1.0.0-alpha.beta \u0026lt; 1.0.0-beta \u0026lt; 1.0.0-beta.2 \u0026lt; 1.0.0-beta.11 \u0026lt; 1.0.0-rc.1 \u0026lt; 1.0.0。  "});index.add({'id':24,'href':'/tags/comment/','title':"comment",'content':""});index.add({'id':25,'href':'/tags/php/','title':"php",'content':""});index.add({'id':26,'href':'/posts/PHP%E6%B3%A8%E9%87%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/','title':"PHP注释最佳实践",'content':"const 常量 常量方便了全局值替换，也有了可读性的名字，但是背后的说明不一定能完整体现到常量名中，所以最好写上注释，如下：\n1 2  const CONTRACT_TYPE_ELECTRONIC = 0;//合同类型-电子  const CONTRACT_TYPE_PAPER = 1;//合同类型-纸质   如上注释有个不好的地方，在编辑器 PHPStorm 中，鼠标悬停看不出注释，注释可以做如下调整，即可悬停查看\n1 2 3 4  /** @var int 合同类型-电子 */ const CONTRACT_TYPE_ELECTRONIC = 0; /** @var int 合同类型-纸质 */ const CONTRACT_TYPE_PAPER = 1   "});index.add({'id':27,'href':'/tags/curl/','title':"curl",'content':""});index.add({'id':28,'href':'/tools/Curl-%E6%8C%87%E5%AE%9A-IP-%E8%AE%BF%E9%97%AE%E7%AD%89%E5%B8%B8%E8%A7%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/','title':"Curl 指定 IP 访问等常规用法总结",'content':"\u0026ndash; resolve 指定ip访问 1  curl --resolve demo:443:127.0.0.1 https://demo/api.json   "});index.add({'id':29,'href':'/tags/cache/','title':"cache",'content':""});index.add({'id':30,'href':'/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98/','title':"浏览器静态资源缓存",'content':"no-cache\n前后端分离坑，\nnginx 配置\n1 2 3 4 5 6 7  index index.php index.html index.htm; location / { add_header Cache-Control no-cache; index index.html index.htm; try_files $uri $uri/ /index.html; }   "});index.add({'id':31,'href':'/posts/PHP%E8%87%AA%E5%8A%A8%E8%A7%A3%E6%9E%90json%E7%94%9F%E6%88%90php%E7%B1%BB%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84json%E5%88%B0php%E5%AF%B9%E8%B1%A1/','title':"PHP自动解析json生成php类文件，自动映射json到php对象",'content':"业务中经常需要对接第三方服务，常用的对接方式就是使用 http json 接口，有些 json 格式较为复杂，使用php数组进行数据交互非常麻烦，非常容易出错。\n1 2 3 4 5 6  $responseStr = \u0026#39;{\u0026#34;foo\u0026#34;:\u0026#34;bar\u0026#34;, \u0026#34;hello\u0026#34;:\u0026#34;world\u0026#34;}\u0026#39;; $responseArr = json_decode($responseStr, true); if($responseArr[\u0026#34;fooo\u0026#34;] == \u0026#34;foobar\u0026#34;) { // do sth.  }   现在 IDE 比如 PHPStorm 也不能对数组 进行代码提示，上面的代码是不会有错误提示的；如果把 json 返回值直接映射到预先定义好的对象，岂不是很舒心？\n一、映射 json 到 php 对象 我们可以使用 composer 包: nixihz/php-object ，支持复杂 json 到 复杂对象之间的映射。\n1 2  composer require nixihz/php-object   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class FooBarClass extends PhpObject { /** @var string */ public $foo; /** @var integer */ public $bar; } class DemoClass extends PhpObject { /** @var FooBarClass */ public $foobar; /** @var FooBarClass[] */ public $foobars; } $json = \u0026#39;{\u0026#34;foobar\u0026#34;:{\u0026#34;foo\u0026#34;:\u0026#34;hello world\u0026#34;,\u0026#34;bar\u0026#34;:64100},\u0026#34;foobars\u0026#34;:[{\u0026#34;foo\u0026#34;:\u0026#34;hello\u0026#34;,\u0026#34;bar\u0026#34;:641},{\u0026#34;foo\u0026#34;:\u0026#34;world\u0026#34;,\u0026#34;bar\u0026#34;:664411}]}\u0026#39;; $demo = (new DemoClass())-\u0026gt;fromJson($json); if($demo-\u0026gt;foobar-\u0026gt;foo == \u0026#34;hello world\u0026#34;) { echo count($demo-\u0026gt;foobars); } var_export($demo);   输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  2 DemoClass::__set_state(array( \u0026#39;foobar\u0026#39; =\u0026gt; FooBarClass::__set_state(array( \u0026#39;foo\u0026#39; =\u0026gt; \u0026#39;hello world\u0026#39;, \u0026#39;bar\u0026#39; =\u0026gt; 64100, )), \u0026#39;foobars\u0026#39; =\u0026gt; array ( 0 =\u0026gt; FooBarClass::__set_state(array( \u0026#39;foo\u0026#39; =\u0026gt; \u0026#39;hello\u0026#39;, \u0026#39;bar\u0026#39; =\u0026gt; 641, )), 1 =\u0026gt; FooBarClass::__set_state(array( \u0026#39;foo\u0026#39; =\u0026gt; \u0026#39;world\u0026#39;, \u0026#39;bar\u0026#39; =\u0026gt; 664411, )), ), ))   下一步，这个工具将会提供直接从 json 生成 php 类代码的辅助功能，将会更大提升对接效率。\n。。。\n二、解析 json 自动生成 php 类文件 来填坑了，安装好 composer require nixihz/php-object 以后，可以使用脚本 vendor/bin/php-object-gen 来直接生成代码到指定文件夹。\nUsage：\n 示例  1 2 3 4 5 6 7  $./vendor/bin/php-object-gen --path=/tmp --json=\u0026#39;{\u0026#34;foo_bar\u0026#34;:{\u0026#34;foo\u0026#34;:1.3,\u0026#34;bar\u0026#34;:[641,641]}}\u0026#39; output Class FooBar saved at: /tmp/FooBar.php Class BaseClass saved at: /tmp/BaseClass.php    -help 查看帮助  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  $./vendor/bin/php-object-gen --help output php object generator Usage: ./vendor/bin/php-object-gen --path=/tmp --json=\u0026#39;{\u0026#34;foo_bar\u0026#34;:{\u0026#34;foo\u0026#34;:1.3,\u0026#34;bar\u0026#34;:[641,641]}}\u0026#39; Flags: --path path to save class files (存储类文件路径) --baseClassName base class name (最外层类名) --fieldCase field case type 0:keep, 1:snake case, 2:camel case (字段形式) --namespace namespace for class (类命名空间) --json json input (待解析的json文件) --help print this help (输出当前帮助信息)    https://github.com/nixihz/php-object\n "});index.add({'id':32,'href':'/sharpen-knife/PHP-storm-%E6%B3%A8%E9%87%8A%E7%AC%A6%E5%8F%B7%E5%9C%A8%E8%A1%8C%E9%A6%96%E8%A7%A3%E5%86%B3/','title':"PHP storm 注释符号在行首",'content':"问题 PHP storm 默认设置 注释快捷键 设置的行注释 设置在行首，如下：❌\n1 2 3 4  // todo 使用队列, 替换 raise dispatchNow  $thread-\u0026gt;raise(new Created($thread)); // ProcessThreadCreated::dispatchNow($thread);  ProcessThreadCreated::dispatch($thread);   使用 格式化 功能以后，格式又发生错乱，❌\n1 2 3 4  // todo 使用队列, 替换 raise dispatchNow  $thread-\u0026gt;raise(new Created($thread)); // ProcessThreadCreated::dispatchNow($thread);  ProcessThreadCreated::dispatch($thread);   注释时直接 注释在代码前，而非行首，如下：✅\n1 2 3 4  // todo 使用队列, 替换 raise dispatchNow  $thread-\u0026gt;raise(new Created($thread)); //ProcessThreadCreated::dispatchNow($thread);  ProcessThreadCreated::dispatch($thread)   解决  设置， 取消勾选 Line Comment at first column  Settings - Editor - Code Style - PHP - Code Generation\n 自动格式化配置，取消勾选 Comment at first column  Settings - Editor - Code Style - PHP - Wrapping and Braces\n"});index.add({'id':33,'href':'/sharpen-knife/','title':"sharpen-knife",'content':"md\n"});index.add({'id':34,'href':'/sharpen-knife/Oh-My-ZSH-on-iTerm-2-%E8%AE%A9Mac%E6%9B%B4%E8%B6%81%E6%89%8B/','title':"Oh My ZSH on iTerm 2 让Mac更趁手",'content':"Oh My ZSH 配置 https://ohmyz.sh/\n插件 autojump\nzsh-autosuggestions\nzsh-syntax-highlighting\n一些 iTerm2 tips iTerm2 使用 sz rz windows xshell 连接远程服务器后与windows电脑互传文件很方便，到了 mac terminal 就不行了，这里推荐一个github项目，原本是某个国外大佬的，结果这个家伙支持藏独，在文件里藏着某些敏感信息，后来前同事把代码拉下来去掉敏感信息后放到自己的项目中。\nhttps://github.com/aikuyun/iterm2-zmodem\n服务端安装 lrzsz: yum install lrzsz\n注意：可以利用 mac自带控制台应用 来排查\n命令行中使用代理 通过设置环境变量 http_proxy\n1  export http_proxy=http://127.0.0.1:7777;export https_proxy=http://127.0.0.1:7777;   配置 badge 徽章 区分环境\n快捷键 1 2 3 4 5 6  cmd + t\t新建tab cmd + d\t垂直分屏 cmd + shift + d\t水平分屏 cmd + 1~9\t切换tab cmd + o\t打开profile   "});index.add({'id':35,'href':'/sharpen-knife/PHPStorm-Visual-Studio-Code-Vim-%E7%86%9F%E6%82%89%E8%BF%99%E4%BA%9B%E7%89%B9%E6%80%A7%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87/','title':"PHPStorm | Visual Studio Code |Vim 熟悉这些特性，提升效率",'content':"PhpStorm 语法错误等提示和检测，调用跳转，代码生成，调试功能，代码全局观，文件管理，版本控制工具，数据库查看，命令行工具，丰富的扩展库。\n文件检测 目录树选中文件，右击，点击 Inspect code … 执行代码检查\n跳转 cmd + 鼠标左键\ncmd + [ 依次返回历史跳转点\ncmd + ] 重新回到最新跳转点\n文件管理 Favorites 文件，根据某个功能特定文件，\nBookmarks\n代码生成 cmd + n 生成代码，弹框中选择生成 Copyright, Getter Setter，注释等\n代码补全 输入 fore 按下回车生成 foreach 代码块 （Goland 也有类似的快捷短语）\n插件 PHP Advanced AutoComplete Thomas Schulz ，可以自动补全，舒心\n定位到当前正在编辑的文件 数据库插件 使用体验与 jetbrains 旗下 Datagrip 非常一致；\n可以在项目中增加 sql 文件夹，存放相关sql；\ncmd + enter 执行光标所在行的sql语句，可以在弹框选择子查询；\ncmd + option + l(小写L) 格式化代码，\ncmd + ，设置中搜索 sql 选择 code style， 可个性化配置sql代码风格。\n比如关键词全部大写，SELECT 子句逗号前置，SELECT 元素独占一行。\nvim插件 享受各个 IDE 一致性的体验。\n一些快捷键    描述 快捷键     提交代码 cmd + k   推送代码 cmd + shift + k   cmd + option + L 格式化代码   精简 import 引入 ctrl + option + o   全局文本搜索 cmd + shift + f   可搜索文件名，配置了数据库，可搜索表名 shift + shift   cmd + e 最近打开文件        Visual Studio Code vim插件 享受各个 IDE 一致性的体验。\nVim 插件\nhttps://github.com/scrooloose/nerdtree.git\nhttps://github.com/vim-airline/vim-airline\nhttps://github.com/vim-airline/vim-airline-themes\n配置\n做好配置，可以放到 git 托管。\nhttps://github.com/fencex/myvim.git\nvim 基础    按键 说明     h j k l ← ↓ ↑ →   ^ 行首   $ 行尾   光标移动下一个单词的结尾 e   w 光标移动下一个单词的开头   光标移动上一个单词的开头 b   gg 第一行   shit + g 最后一行   ctrl + d 向下翻半页   向上翻半页 ctrl + u   / 搜索（ linux命令 less 也用 / 来搜索）   * shift + 8 搜索当前光标所在的单词   n 向下搜索   shift + n 向上搜索    编辑操作    按键 说明     i 进入插入模式   esc 退出插入模式   dd 删除行   删除光标之后的单词 dw   删除光标到行尾， d^ 同理 d$   yy 复制行   p 粘贴   u 撤销操作   重做撤销的操作 ctrl + r    Visual 模式    按键 说明     v 选择   shift + v 行选   ctrl + v 块选    一般跟其他命令结合使用，比如 shift + v 选择多行， 再按 d， 删除所选行\n命令    说明 按键     保存 :w   :wq （shift + z + z） 保存并退出，（按住 shift 再按2下 z）   退出，如果有修改未保存在不能退出 :q   强制退出，有修改未保存也能退出 :q!   返回 shell 模式 :sh   shell 模式中 输入 exit 返回 vim 模式   按行搜索并替换，不加 g 表示替换每行第一次搜索的词，加g表示替换所有； :%s/待替换/替换为/g   % 表示所有行 :1,4s/待替换/替换为/g   自定义行 shift + v 行选模式:s   定位到第 1000 行 :10000    其他  shift + j 当前行移动到上一行行尾, 可以做到单列转单行 shift + u 转换成大写 ~ 大小写互换  "});index.add({'id':36,'href':'/sharpen-knife/MacOS%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/','title':"MacOS必备软件",'content':"Magnet 一款辅助视窗排版的软件，花6块钱实现与windows自带的排版相同的体验吧。\n"});index.add({'id':37,'href':'/sharpen-knife/MacOS%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%92%8C%E8%AE%BE%E7%BD%AE%E8%AE%A9Mac%E6%9B%B4%E8%B6%81%E6%89%8B/','title':"MacOS系统配置和设置，让Mac更趁手",'content':"触摸板 🔵 滚动方向：自然，设计思路：内容虽手指移动， 推荐勾选 ✅\n🔘滚动方向：自然，设计思路：我要看下面的内容，手指就往下滑\n🔵 轻点来点按， 勾选上，可以触摸来点击，否则需要用力按下，非常废手指，因此强烈推荐勾选上✅。\n三指拖动 还有一个操作非常费手指，选中部分文本, mac 提供一个解决方案：三指拖动，其实就是使用三指滑动来实现单击并拖拽。\n 移动窗口 选中文本  三指滑动开始选中，可以多次滑动来调整结束位置，(注意中间的停顿不能太久)。\n触发角功能 我个人比较喜欢这个功能，屏幕有四个活跃触发角，可以设定不同的功能，比如调度中心，应用程序窗口，说的花里胡哨的，窗口缩略图，当前焦点应用的窗口缩略图。\n我比较喜欢的设置如图。\n左下角设置成启动屏幕保护程序 ，老板走过来了，立马用鼠标或者触摸板把光标移动到左下角。程序员的电脑重要数据还是比较多的，为安全考虑，建议大家设置，或者你也可以直接盖上盖子。\n当然这一步仅是启动了屏保，大家设置了以后可能敲击键盘，或者移动鼠标，就退出屏保动画，进入系统了。\n进一步操作，让电脑进入屏保立马锁定电脑。如下图：\n大家可以体验一下，设定启动屏保的触发角，鼠标指针停留一段时间才会触发，而其他则立即触发，这些都是细节，真牛*。\n其他  触摸板双指滑动，切换上一页下一页 双指点击，放大缩小 双指右侧滑动，打开通知窗口， 大家分享时，记得开启勿扰模式  键盘  按键重复 和 重复前延迟设置最快和最短移动光标体验起飞。 开发常用F1-F12功能键，推荐使用按 Fn 键以 显示 F1、F2 等键  一些快捷键    描述  快捷键     窗口切换，可以加 shift 反向切换 macos cmd + tab   同一应用窗口切换，可以加 shift 反向切换 macos cmd + `(反引号)|   隐藏窗口（可通过 cmd + tab 切换） macos cmd + h   最小化窗口 （不可通过 cmd + tab 切换） macos cmd + m   macos ctrl + ← 切换到左侧窗口空间，四指左滑   切换到右侧窗口空间， 四指右滑 macos ctrl + →   查看窗口缩略图，四指上滑 macos ctrl + ↑   查看同应用的窗口缩略图 macos ctrl + ↓   打开 emoji 选择器🚀 macos ctrl + cmd + space    一些光标定位快捷键    快捷键  描述     cmd + x macos 剪切当前行   cmd + ← macos 光标到行首   cmd + → macos 光标到行尾   选中光标到行首的文本 cmd + shift + ← macos   macos 选中光标到行尾的文本 cmd + shift + →   ctrl + a *unix 光标到行首 ahead   ctrl + e *unix 光标到行尾 end   ctrl + f *unix 光标向右1个字符 forward   光标向左1个字符 backward ctrl + b *unix   ctrl + w *unix 向左清除一个单词 word   ctrl + k *unix 删除当前光标到行尾   ctrl + u *unix 删除整行输入 undo   ctrl + y *unix 上一步的重做   ctrl + c *unix 取消输入，会保留输入文本 cancel   清屏 ctrl + l (小写L) *unix   ctrl + r *unix 搜索历史命令记录    "});index.add({'id':38,'href':'/tags/app/','title':"app",'content':""});index.add({'id':39,'href':'/tags/flutter/','title':"flutter",'content':""});index.add({'id':40,'href':'/flutter-music-app/Flutter-%E9%9F%B3%E4%B9%90-app-%E4%B9%8B-%E4%BD%BF%E7%94%A8-sqlite-%E5%AD%98%E5%82%A8%E6%AD%8C%E6%9B%B2%E4%BF%A1%E6%81%AF%E5%92%8C%E6%AD%8C%E5%8D%95%E6%96%87%E4%BB%B6%E5%A4%B9/','title':"Flutter 音乐 app 之 使用 sqlite 存储歌曲信息和歌单文件夹",'content':""});index.add({'id':41,'href':'/flutter-music-app/','title':"flutter-music-app",'content':"md\n"});index.add({'id':42,'href':'/tags/sqlite/','title':"sqlite",'content':""});index.add({'id':43,'href':'/flutter-music-app/Flutter-%E9%9F%B3%E4%B9%90-app-%E4%B9%8B-%E5%8A%A0%E4%B8%80%E4%B8%AA-WiFi-%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%8A%9F%E8%83%BD%E5%90%A7/','title':"Flutter 音乐 app 之 加一个 WiFi 文件同步功能吧",'content':"既然是音乐播放器，那得搞些资源放进手机吧，兄弟你看小说吗？很多 app 有通过 Wi-Fi 把书传入手机的功能，效果还行，那就这么搞吧。\n简单画一个图：\n先看下实际效果图吧！\nFlutter 启动 http 服务 使用 内置的 HttpServer ，代码如下：\n1 2 3 4 5 6 7  import \u0026#39;dart:io\u0026#39;; server = await HttpServer.bind( hostIp, 8080, );   这就启动了一个 http 服务，这不是搞笑呢吗？请求咋处理，静态资源咋放这咋没说呢，稍候我先去吃个饭。\n服务路由 由于该服务只有特定的几个功能，创建文件夹，获取列表，上传文件，删除文件，以及前端页面文件，所以路由功能直接根据 request uri ，进行 switch case 即可，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // runZoned 捕获异步异常  var runZoned2 = runZoned(() async { await for (var request in server) { switch (request.uri.toString().split(\u0026#34;?\u0026#34;).first) { case \u0026#39;/upload\u0026#39;: _uploadController(request); break; case \u0026#39;/musicList\u0026#39;: _musicListController(request); break; case \u0026#39;/deleteMusicInfo\u0026#39;: _deleteMusicController(request); break; case \u0026#39;/createFold\u0026#39;: _createFoldController(request); break; case \u0026#39;/\u0026#39;: _homeController(request); break; default: _publicController(request); break; } } }, onError: (Object obj, StackTrace stack) { print(obj); print(stack); }); }   请求前端文件 前端功能不复杂，但是有一些交互，直接用 Vue 写一个 SPA，来的快一些。vue 打包以后把所有的文件放在 {project}/assets/httpserver/ 文件夹下即可访问。\n比较难受的是，http 响应头 Response Header 中 ContentType Content-Length 等要自己写，不能自动识别，这个比较考验 http 基本概念的理解了，如果有更好的实现方式，请留言，先谢过了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  // http 的静态资源资源  _publicController(HttpRequest request) { String filePath = \u0026#34;assets/httpserver/public\u0026#34; + request.uri.path.toString(); String filetype = filePath.split(\u0026#39;.\u0026#39;).last; String type1 = \u0026#39;text\u0026#39;; String type2 = \u0026#39;html\u0026#39;; if (filetype == \u0026#39;html\u0026#39;) { type2 = \u0026#39;html\u0026#39;; } else if (filetype == \u0026#39;js\u0026#39;) { type1 = \u0026#39;application\u0026#39;; type2 = \u0026#39;javascript\u0026#39;; } else if (filetype == \u0026#39;css\u0026#39;) { type2 = \u0026#39;css\u0026#39;; } else if (filetype == \u0026#39;ico\u0026#39;) { type2 = \u0026#39;ico\u0026#39;; } else if (filetype == \u0026#39;png\u0026#39;) { type1 = \u0026#39;image\u0026#39;; type2 = \u0026#39;png\u0026#39;; } else if (filetype == \u0026#39;map\u0026#39;) { type2 = \u0026#39;html\u0026#39;; } else if (filetype == \u0026#39;woff\u0026#39;) { type1 = \u0026#39;font\u0026#39;; type2 = \u0026#39;woff\u0026#39;; } if (type2 == \u0026#34;woff\u0026#34; || type2 == \u0026#34;ttf\u0026#34; || type2 == \u0026#34;ico\u0026#34; || type2 == \u0026#34;png\u0026#34;) { rootBundle.load(fielPath).then((value) { request.response ..headers.clear() ..headers.contentType = new ContentType(type1, type2, charset: \u0026#34;UTF-8\u0026#34;) ..headers.set(\u0026#34;Accept-Ranges\u0026#34;, \u0026#34;bytes\u0026#34;) ..headers.set(\u0026#34;Connection\u0026#34;, \u0026#34;keep-alive\u0026#34;) ..headers.set(\u0026#34;Content-Length\u0026#34;, value.lengthInBytes) ..add(value.buffer.asUint8List()) ..close(); }); } else { rootBundle.load(fielPath).then((value) { request.response ..headers.clear() ..headers.contentType = new ContentType(type1, type2, charset: \u0026#34;UTF-8\u0026#34;) ..headers.set(\u0026#34;Accept-Ranges\u0026#34;, \u0026#34;bytes\u0026#34;) ..headers.set(\u0026#34;Connection\u0026#34;, \u0026#34;keep-alive\u0026#34;) ..headers.set(\u0026#34;Content-Length\u0026#34;, value.lengthInBytes) ..write(utf8.decode(value.buffer.asUint8List())) ..close(); }); } }   请求功能接口 相较于静态文件，接口反而简单点，以 音乐列表 示例：\n功能：传入一个 文件路径，获取该路径下的音乐文件列表。\n 获取 GET 参数 path： request.uri.queryParameters[\u0026quot;path\u0026quot;] 从 sqlite 读取数据 按照与前端约定的格式响应 json  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 列表页  _musicListController(HttpRequest request) async { HttpBodyHandler.processRequest(request).then((body) async { String musicPath = request.uri.queryParameters[\u0026#34;path\u0026#34;]; // 从 sqlite 读取数据  DBProvider.db.getMusicInfoByPath(musicPath).then((onValue) { Map map = new Map(); map[\u0026#34;List\u0026#34;] = onValue; map[\u0026#34;Total\u0026#34;] = onValue.length; // HttpServerUtils 代码文件见附录：  HttpServerUtils.response(request, 200, \u0026#34;Success\u0026#34;, map); }); }); }   附录： HttpServerUtils.dart\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  import \u0026#39;dart:convert\u0026#39;; import \u0026#39;dart:io\u0026#39;; class HttpServerUtils { static response(HttpRequest httpRequest, int code, String msg, Map data) { var resp = \u0026#34;{}\u0026#34;; Responses response = new Responses(data: data, code: 200, message: \u0026#34;Success\u0026#34;); resp = jsonEncode(response); httpRequest.response ..headers.clear() ..headers.contentType = new ContentType(\u0026#34;application\u0026#34;, \u0026#34;json\u0026#34;, charset: \u0026#34;UTF-8\u0026#34;) ..headers.set(\u0026#34;Accept-Ranges\u0026#34;, \u0026#34;bytes\u0026#34;) ..headers.set(\u0026#34;Connection\u0026#34;, \u0026#34;keep-alive\u0026#34;) ..headers.set(\u0026#34;Content-Length\u0026#34;, utf8.encode(musicInfoJson).length) ..add(utf8.encode(resp)) ..close(); } } // 自定义响应的格式  class Responses { final Map data; final int code; final String message; Responses({this.data, this.code, this.message}); Map toJson() { Map map = new Map(); map[\u0026#34;Data\u0026#34;] = this.data; map[\u0026#34;Code\u0026#34;] = this.code; map[\u0026#34;Message\u0026#34;] = this.message; return map; } }   "});index.add({'id':44,'href':'/tags/wifi-sync/','title':"wifi sync",'content':""});index.add({'id':45,'href':'/flutter-music-app/%E5%BC%80%E7%AF%87%E8%AF%8D/','title':"开篇词",'content':"过年没啥事，写一个 flutter 音乐播放器吧\n"});index.add({'id':46,'href':'/posts/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE-npm-%E5%8C%85%E7%AE%A1%E7%90%86%E8%8E%AB%E5%90%8D%E5%8D%87%E7%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/','title':"前端项目 npm 包管理莫名升级问题排查",'content':"package.json 和 package-lock.json 是控制node_module包版本的两个文件，其中 package.json 由开发者维护，package-lock.json 自动生成。\n一般package.json 指定版本都会使用 ^ 或者 ~ ，举例：\n1 2 3 4  \u0026#34;dependencies\u0026#34;: { \u0026#34;vue\u0026#34;: \u0026#34;^2.6.11\u0026#34;, \u0026#34;vue-pdf\u0026#34;: \u0026#34;~4.0.8\u0026#34; }   ^2.6.11 表示该模块的小版本向下兼容，\n~4.0.8 表示该模块的中间\n执行 npm install 到底发生了什么；\n~1.2.3 代表 1.2.3 \u0026lt;= 版本号 \u0026lt; 1.3.0\n^1.2.3 代表 1.2.3 \u0026lt;= 版本号 \u0026lt; 2.0.0\n1，^ 符号，它与semantic versioning （语义版本控制）有关系，它表示尽量使用最新版本，但保证不产生兼容问题，换句话说也就是除了大版本号以外，小版本号和补丁版本号都可以变。 但0 开头的版本号是比较特殊的，而因为 ^ 严格遵守 semantic versioning 规则，所以会出现以下情况（早先的 composer 版本并没有这样的处理，后来修正了）：^0.3.0 等于 \u0026gt;=0.3.0; \u0026lt;0.4.0，并不是\u0026lt;1.0.0 ，因为，semantic versioning 的规定是，大版本号以 0 开头表示这是一个非稳定版本（unstable），如果处于非稳定状态，小版本号是允许不向下兼容的！\n2，~符号，表示版本号只能改变最末尾那段（如果是 ~x.y 末尾就是 y，如果是 ~x.y.z 末尾就是 z），比如这种情况:\n~1.2 等于 \u0026gt;=1.2.0; \u0026lt;2.0.0\n3，因为0的特殊性所以如果你要指定 0 开头的库那一定要注意：\n~0.1 这种写法是很危险的，因为 ~0.1 等于 \u0026gt;=0.1.0; \u0026lt;1.0.0，可能出现无法向下兼容的情况，比较保险的写法还是：^0.1（等于 \u0026gt;=0.1.0; \u0026lt;0.2.0）\n"});index.add({'id':47,'href':'/posts/SPA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5/','title':"SPA前端项目灰度发布策略",'content':"前提 B/S 项目的灰度发布本应完全由服务端控制，但是SPA的出现打破了这个局面，B/S变得越来越像C/S，故发布策略也需要做相应调整。\n灰度发布（又名金丝雀发布），在此基础上，我们可以做内测，也可以做 A/B 测试，战略意义还是很大的。\n简单思路todo： 常规项目 npm 打包，同一版本的代码，每次打包静态文件名必须一致，\nwebpack中hash、chunkhash、contenthash 区别\n使用 contenthash 作文件名， 或者使用自定义版本号来维护。\n打包完成，手动提交版本号到服务端，由服务端纳入灰度发布的控制\n项目入口文件 不再直接使用 dist/index.html\n而是由服务端来控制\n用户登录后，服务端可以任意控制用户应该访问哪个版本的前端；\n前端项目的每次请求都必须带上版本号：由服务端处理做后续处理，\n比如：\n有版本太旧，可提示用户刷新，刷新以后依然如此，可以提示向后台反馈；\n好处：\n 提前获得目标用户的使用反馈； 根据反馈结果，做到查漏补缺； 发现重大问题，可回滚“旧版本”； 补充完善产品不足； 快速验证产品的 idea。  "});index.add({'id':48,'href':'/tags/password/','title':"password",'content':""});index.add({'id':49,'href':'/posts/PHP-%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E8%AE%BE%E8%AE%A1/','title':"PHP 项目的用户密码设计",'content':"简单聊一聊用户系统的密码存储设计\n历史变迁 首先，最开始大家用的都是明文存储用户的密码，想着，反正存储在服务端，也只有服务端看得到，\n但这些年这么多脱裤事件，终于意识到不能再使用明文了，\n于是，大家改用 md5 等哈希算法，为用户密码“加密”，但数据库泄漏后，仍然可以使用 字典攻击 破解。字典攻击 是用一个字典文件，储存了单词、短语、常用密码和他们 hash 后结果。将密码与 hash 结果对比，就能破解。\n为了解决这个问题，研发工程师又在密码的hash的过程中加 salt， salt是一串随机值，与 hash 后的密码一起保存在数据库。 这恐怕只能使用暴力破解了，但现在GPU的发展，使得暴力破解成为可能，如果被脱裤，则更容易破解。\n同时期的 GPU 的计算单元比CPU多， L1/L2/L3缓存和控制器较少， 所以GPU非常适合做并行且无需内存参与的计算任务。\n解决方案 PHP 5.5 开始， 针对于 password， 给出了轻便的解决方案：password_hash（加密）、 password_verify（验证校验）、 password_need_rehash（判断是否需要重新加密）；\n这一套password解决方案，首先是把 salt 值体现到了 hash 值里面，这样就不需要在维护一个 salt 字段，再者支持了 BCRYPT, ARGON 算法。\nBCRYPT 这个算法，相比md5 是一个慢速hash，比较消耗cpu， md5 毫秒级别， bcrypt 0.1 秒级别 ；我们一直想让代码运行的快点再快点，而加密算法反其道而行。\n针对这个算法， 并且可以设置 cost，来调整耗时，假设后续机器性能大提升，也可以修改 cost；\n上文也提到了，GPU等硬件升级会导致破解速度的加快。\n第二种算法，在2015年密码hash竞赛中诞生，并且拿了冠军， 那就是 argon2， 这种算法使用大量内存和大量计算资源进行 Hash 计算， 内存和GPU的数据传输是很慢的（不展开讲）， 可能就是 0.2 s 的级别。可以设置 memory_cost，time_cost **两种 cost 来调整运算的耗时。\n扩展 argon 有3个分支，详细可以线下去了解： PHP 版本 7.2+\n Argon2d：更快，使用 data-dependent 的内存访问方式，data 是需要 Hash 的 password 和 salt。适合加密货币和不会收到 side-channel timing 攻击的应用。 Argon2i：使用 data-independent 的内存访问方式，更适合密码哈希等。他比 Argon2d 慢，因为它需要更多次内存计算（passes）来保护免受 tradeoff 的攻击。 Argon2id：是 Argon2i 和 Argon2d 的混合版本，第一次计算用 Argon2i，后续的计算用 Argon2d。如果没有特定的理由，推荐使用 Argon2id。  Argon 需要 安装 sodium 扩展\n"});index.add({'id':50,'href':'/posts/PHP%E5%AF%B9%E6%8E%A5-wsdl-soap-%E6%8E%A5%E5%8F%A3/','title':"PHP 对接 wsdl soap 接口",'content':"概念\nSOAP\nWSDL\nWSDL 描述了业务方法，各语言基本都提供了工具可以自动生成代码，可以直接调用；对接就变得非常简单，拢共就2步骤：\n 自动生成接口代码 封装 service 提供给业务调用  1. 自动生成接口代码 PHP 要处理 SOAP，可以使用这个库，https://github.com/phpro/soap-client\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  $ composer require phpro/soap-client $ ./vendor/bin/soap-client wizard Where would you like to store your config file? [config/soap-client.php]: \u0026gt; common/config/soap-client.php Wsdl location (URL or path to file): \u0026gt; common/config/standard-prod.wsdl Generic name used to name this client (Results in \u0026lt;name\u0026gt;Client \u0026lt;name\u0026gt;Classmap etc.): \u0026gt; GoogleMap Directory where the client should be generated in: \u0026gt; common/libs/googlemap Namespace for your client: \u0026gt; common\\libs\\googlemap [OK] Config has been written to common/config/soap-client.php Generated class common\\libs\\googlemap\\Type\\PingRequest to common/libs/googlemap/Type/PingRequest.php ... [OK] All SOAP types generated [OK] Generated classmap at common/libs/googlemap/GoogleMapClassmap.php [OK] Generated client at common/libs/googlemap/GoogleMapClient.php [OK] Generated client factory at common/libs/googlemap/GoogleMapClientFactory.php   2. 封装 service 提供给业务调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;?php namespace service\\supplier\\googlemap; use common\\libs\\googlemap\\GooglaMapClientFactory; class MapService { protected $client; public function __construct() { $this-\u0026gt;client = GooglaMapClientFactory::factory(\u0026#34;/path/to/config/standard-prod.wsdl\u0026#34;); } // 调用 soap 实际业务方法  public function getA() { return $this-\u0026gt;client-\u0026gt;getA(); } }   写在结尾 越来越多接口提供商都不再使用 wsdl / soap 对外服务了，性能很差，我对接过的服务商基本都改成轻量的 json 格式，甚至改成了 grpc\n"});index.add({'id':51,'href':'/tags/tool/','title':"tool",'content':""});index.add({'id':52,'href':'/tags/vscode/','title':"vscode",'content':""});index.add({'id':53,'href':'/sharpen-knife/%E6%98%BE%E7%A4%BA-/','title':"显示 **vscode 的 tab 和空格**",'content':"文字中的空白到底是tab和空格？ 开发测试过程中，我们可能需要构造各种tab分割的文本数据，然而默认配置下，输入tab，就被转化成了4个空格，为了避免这些坑，我们来尝试做些处理。\n显示空白 设置中搜索renderWhitespace，设置为all\nRenderImage when len(FileIDs) == 0 NYI 这个时候，就能看出空白到底是tab还是空格，如图：\nRenderImage when len(FileIDs) == 0 NYI 这一步操作不仅能显示tab和空格，而且区分了 tab 和 空格\n 拷贝文本，保留tab 输入文本，替换tab为4个空格  "});index.add({'id':54,'href':'/posts/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%9C%89%E5%BA%8F%E5%9C%B0%E6%8E%A5%E6%89%8B%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/','title':"如何快速有序地接手一个项目",'content':"见过一些人在接受一个老项目后，开始阅读~~~~一行一行代码，终于3个月后熟悉了整个项目。\n软件开发生涯中，一定会遇到一只拦路虎『老项目』，循此规蹈此矩，你可能真的可以骑着『老虎』前进。\n一切拦路虎都是纸老虎\n情报收集 既然是老项目，最大的特质就是陌生，面对陌生的事物，切不可着急下手，第一步须收集各种情报，让这个项目在脑子里更立体，更形象。\n情报来源-产品相关 产品体验（前后台）、历代产品迭代文档、相关产品人员沟通等，通过这些手段明确：\n 产品功能，目标用户，竞品和对标产品 体验中根据经验勾勒出来的大概的代码设计 需要研发经常介入的操作 历史上出现过的重大bug，常现bug 产品人员对之前研发的评价 \u0026hellip;  情报来源-技术相关 之前负责人的交接文档，研发产出的设计文档，开发文档，对接文档，可能至少有2周时间和之前负责团队进行交接，通过这些手段明确：\n 主流程图，框架图 设计细节：分库， 技术框架、第三方类库， 组件及用途：mysql redis kafka nginx 等 第三方服务：推送等文档 流程上下游：前端，大数据等 你对交接人的评价 \u0026hellip;  如果上述不能给出，需要自己根据产品相关和下面的情报自己整理。\n情报来源-代码和环境 到此『纸老虎』的框架已经出来了， 再来把血肉给拼接上。可以开始分模块阅读手上的代码，同时让运维同事把线上环境各项配置罗列出来，最后需要明确：\n 线上环境配置：硬件配置，软件配置 线上机器压力和波峰波谷情况 自动任务crontab，常驻任务 上线流程 涉及代码异构，和上下游交互明细，redis key，restful api文档 熟悉单元测试 索要所有的证书，凭证，密码等 \u0026hellip;待续  情报处理 有了如上手段和目标，就可以着手整理属于自己的认知文档了（不同项目可能步骤有不同）。\n"});index.add({'id':55,'href':'/blog/new-url/','title':"template",'content':""});index.add({'id':56,'href':'/categories/','title':"Categories",'content':""});})();